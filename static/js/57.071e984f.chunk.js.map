{"version":3,"sources":["lib/hooks/swap/index.ts","lib/hooks/transactions/index.tsx","lib/hooks/swap/useSwapInfo.tsx","lib/hooks/routing/useClientSideSmartOrderRouterTrade.ts","lib/state/transactions.ts","lib/hooks/swap/useBestTrade.ts","lib/hooks/useTransactionDeadline.ts","lib/components/Swap/SwapButton.tsx"],"names":["amountAtom","pickAtom","swapAtom","useSwitchSwapCurrencies","update","useUpdateAtom","useCallback","swap","oldOutput","Field","OUTPUT","INPUT","independentField","useSwapCurrency","field","atom","useMemo","otherAtom","otherField","useAtom","currency","setCurrency","otherCurrency","useAtomValue","switchSwapCurrencies","setOrSwitchCurrency","useSwapAmount","amount","independentFieldAtom","value","undefined","updateSwap","updateAmount","useIsAmountPopulated","Boolean","usePendingTransactions","chainId","useActiveWeb3React","txs","transactionsAtom","useAddTransaction","blockNumber","useBlockNumber","updateTxs","info","invariant","txChainId","hash","response","chainTxs","addedTime","Date","getTime","lastCheckedBlockNumber","usePendingApproval","token","spender","Object","values","find","tx","receipt","type","TransactionType","APPROVAL","tokenAddress","address","spenderAddress","transaction","now","TransactionsUpdater","pendingTransactions","onCheck","Math","max","onReceipt","BAD_RECIPIENT_ADDRESSES","swapInfoAtom","currencies","currencyBalances","currencyAmounts","trade","state","TradeState","INVALID","allowedSlippage","Percent","feeOptions","SwapInfoUpdater","setSwapInfo","swapInfo","account","inputCurrency","outputCurrency","feeOptionsAtom","to","relevantTokenBalances","useCurrencyBalances","isExactIn","parsedAmount","tryParseCurrencyAmount","useBestTrade","TradeType","EXACT_INPUT","EXACT_OUTPUT","inputAmount","outputAmount","autoSlippageTolerance","useAutoSlippageTolerance","maxSlippage","maxSlippageAtom","inputError","formattedTo","isAddress","maximumAmountIn","balanceIn","amountIn","lessThan","symbol","useComputeSwapInfo","useEffect","useSwapInfo","config","protocols","Protocol","V2","V3","useClientSideSmartOrderRouterTrade","tradeType","amountSpecified","library","currencyIn","currencyOut","queryArgs","useRoutingAPIArguments","tokenIn","tokenOut","useClientSideRouter","params","provider","useState","loading","setLoading","quoteResult","error","setFetchedResult","a","getClientSideQuote","result","data","fetchQuote","route","computeRoutes","gasUseEstimateUSD","useStablecoinAmountFromFiatValue","LOADING","otherAmount","CurrencyAmount","fromRawAmount","quote","length","NO_ROUTE_FOUND","transformRoutesToTrade","VALID","e","console","debug","atomWithImmer","useDebounce","debouncedAmount","debouncedOtherCurrency","clientSORTrade","getTradeInputs","amountFromLatestTrade","currencyFromTrade","otherCurrencyFromTrade","debouncing","syncing","amounts","indepdenentCurrencies","dependentCurrencies","amountsMatch","equalTo","currenciesMatch","equals","isTradeDebouncing","useFallback","fallbackTrade","useClientSideV3Trade","SYNCING","useDefaultTransactionTtl","L2_CHAIN_IDS","includes","L2_DEADLINE_FROM_NOW","DEFAULT_DEADLINE_FROM_NOW","useTransactionTtl","transactionTtlAtom","useTransactionDeadline","ttl","defaultTtl","blockTimestamp","useCurrentBlockTimestamp","add","EtherscanA","styled","useIsPendingApproval","SwapButton","disabled","tokenColorExtraction","useTheme","inputCurrencyBalance","inputCurrencyAmount","outputCurrencyAmount","activeTrade","setActiveTrade","optimizedTrade","useSwapApprovalOptimizedTrade","useSwapApproval","approval","getApproval","approvalHash","isToken","useSwapRouterAddress","addTransaction","addApprovalTransaction","then","actionProps","greaterThan","ApprovalState","PENDING","message","href","CHAIN_INFO","explorer","target","gap","action","icon","Spinner","NOT_APPROVED","deadline","signatureData","useERC20PermitFromTrade","swapCallback","useSwapCallback","recipientAddressOrName","callback","setDisplayTxHash","displayTxHashAtom","onConfirm","SWAP","catch","log","finally","color","onClick","onUpdate","onClose"],"mappings":"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","file":"static/js/57.071e984f.chunk.js","sourcesContent":["import { Currency } from '@uniswap/sdk-core'\nimport { useAtom } from 'jotai'\nimport { useAtomValue, useUpdateAtom } from 'jotai/utils'\nimport { pickAtom } from 'lib/state/atoms'\nimport { Field, independentFieldAtom, swapAtom } from 'lib/state/swap'\nimport { useCallback, useMemo } from 'react'\nexport { default as useSwapInfo } from './useSwapInfo'\n\nexport const amountAtom = pickAtom(swapAtom, 'amount')\n\nfunction otherField(field: Field) {\n  switch (field) {\n    case Field.INPUT:\n      return Field.OUTPUT\n      break\n    case Field.OUTPUT:\n      return Field.INPUT\n      break\n  }\n}\n\nexport function useSwitchSwapCurrencies() {\n  const update = useUpdateAtom(swapAtom)\n  return useCallback(() => {\n    update((swap) => {\n      const oldOutput = swap[Field.OUTPUT]\n      swap[Field.OUTPUT] = swap[Field.INPUT]\n      swap[Field.INPUT] = oldOutput\n      switch (swap.independentField) {\n        case Field.INPUT:\n          swap.independentField = Field.OUTPUT\n          break\n        case Field.OUTPUT:\n          swap.independentField = Field.INPUT\n          break\n      }\n    })\n  }, [update])\n}\n\nexport function useSwapCurrency(field: Field): [Currency | undefined, (currency?: Currency) => void] {\n  const atom = useMemo(() => pickAtom(swapAtom, field), [field])\n  const otherAtom = useMemo(() => pickAtom(swapAtom, otherField(field)), [field])\n  const [currency, setCurrency] = useAtom(atom)\n  const otherCurrency = useAtomValue(otherAtom)\n  const switchSwapCurrencies = useSwitchSwapCurrencies()\n  const setOrSwitchCurrency = useCallback(\n    (currency?: Currency) => {\n      if (currency === otherCurrency) {\n        switchSwapCurrencies()\n      } else {\n        setCurrency(currency)\n      }\n    },\n    [otherCurrency, setCurrency, switchSwapCurrencies]\n  )\n  return [currency, setOrSwitchCurrency]\n}\n\nexport function useSwapAmount(field: Field): [string | undefined, (amount: string) => void] {\n  const amount = useAtomValue(amountAtom)\n  const independentField = useAtomValue(independentFieldAtom)\n  const value = useMemo(() => (independentField === field ? amount : undefined), [amount, independentField, field])\n  const updateSwap = useUpdateAtom(swapAtom)\n  const updateAmount = useCallback(\n    (amount: string) =>\n      updateSwap((swap) => {\n        swap.independentField = field\n        swap.amount = amount\n      }),\n    [field, updateSwap]\n  )\n  return [value, updateAmount]\n}\n\n// check if any amount has been entered by user\nexport function useIsAmountPopulated() {\n  return Boolean(useAtomValue(amountAtom))\n}\n","import { Token } from '@uniswap/sdk-core'\nimport { useAtomValue, useUpdateAtom } from 'jotai/utils'\nimport useActiveWeb3React from 'lib/hooks/useActiveWeb3React'\nimport { Transaction, TransactionInfo, transactionsAtom, TransactionType } from 'lib/state/transactions'\nimport ms from 'ms.macro'\nimport { useCallback } from 'react'\nimport invariant from 'tiny-invariant'\n\nimport useBlockNumber from '../useBlockNumber'\nimport Updater from './updater'\n\nfunction isTransactionRecent(transaction: Transaction) {\n  return Date.now() - transaction.addedTime < ms`1d`\n}\n\nexport function usePendingTransactions() {\n  const { chainId } = useActiveWeb3React()\n  const txs = useAtomValue(transactionsAtom)\n  return (chainId ? txs[chainId] : null) ?? {}\n}\n\nexport function useAddTransaction() {\n  const { chainId } = useActiveWeb3React()\n  const blockNumber = useBlockNumber()\n  const updateTxs = useUpdateAtom(transactionsAtom)\n\n  return useCallback(\n    (info: TransactionInfo) => {\n      invariant(chainId)\n      const txChainId = chainId\n      const { hash } = info.response\n\n      updateTxs((chainTxs) => {\n        const txs = chainTxs[txChainId] || {}\n        txs[hash] = { addedTime: new Date().getTime(), lastCheckedBlockNumber: blockNumber, info }\n        chainTxs[chainId] = txs\n      })\n    },\n    [blockNumber, chainId, updateTxs]\n  )\n}\n\n/** Returns the hash of a pending approval transaction, if it exists. */\nexport function usePendingApproval(token?: Token, spender?: string): string | undefined {\n  const { chainId } = useActiveWeb3React()\n  const txs = useAtomValue(transactionsAtom)\n  if (!chainId || !token || !spender) return undefined\n\n  const chainTxs = txs[chainId]\n  if (!chainTxs) return undefined\n\n  return Object.values(chainTxs).find(\n    (tx) =>\n      tx &&\n      tx.receipt === undefined &&\n      tx.info.type === TransactionType.APPROVAL &&\n      tx.info.tokenAddress === token.address &&\n      tx.info.spenderAddress === spender &&\n      isTransactionRecent(tx)\n  )?.info.response.hash\n}\n\nexport function TransactionsUpdater() {\n  const pendingTransactions = usePendingTransactions()\n\n  const updateTxs = useUpdateAtom(transactionsAtom)\n  const onCheck = useCallback(\n    ({ chainId, hash, blockNumber }) => {\n      updateTxs((txs) => {\n        const tx = txs[chainId]?.[hash]\n        if (tx) {\n          tx.lastCheckedBlockNumber = tx.lastCheckedBlockNumber\n            ? Math.max(tx.lastCheckedBlockNumber, blockNumber)\n            : blockNumber\n        }\n      })\n    },\n    [updateTxs]\n  )\n  const onReceipt = useCallback(\n    ({ chainId, hash, receipt }) => {\n      updateTxs((txs) => {\n        const tx = txs[chainId]?.[hash]\n        if (tx) {\n          tx.receipt = receipt\n        }\n      })\n    },\n    [updateTxs]\n  )\n\n  return <Updater pendingTransactions={pendingTransactions} onCheck={onCheck} onReceipt={onReceipt} />\n}\n","import { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Percent, TradeType } from '@uniswap/sdk-core'\nimport { FeeOptions } from '@uniswap/v3-sdk'\nimport useAutoSlippageTolerance from 'hooks/useAutoSlippageTolerance'\nimport { atom } from 'jotai'\nimport { useAtomValue, useUpdateAtom } from 'jotai/utils'\nimport { useCurrencyBalances } from 'lib/hooks/useCurrencyBalance'\nimport { maxSlippageAtom } from 'lib/state/settings'\nimport { feeOptionsAtom, Field, swapAtom } from 'lib/state/swap'\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount'\nimport { ReactNode, useEffect, useMemo } from 'react'\nimport { InterfaceTrade, TradeState } from 'state/routing/types'\n\nimport { isAddress } from '../../../utils'\nimport useActiveWeb3React from '../useActiveWeb3React'\nimport { useBestTrade } from './useBestTrade'\n\ninterface SwapInfo {\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  currencyAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  trade: {\n    trade?: InterfaceTrade<Currency, Currency, TradeType>\n    state: TradeState\n  }\n  allowedSlippage: Percent\n  feeOptions: FeeOptions | undefined\n}\n\nconst BAD_RECIPIENT_ADDRESSES: { [address: string]: true } = {\n  '0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10': true, // v2 factory\n  '0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106': true, // v2 router 01\n  '0x60aE616a2155Ee3d9A68541Ba4544862310933d4': true, // v2 router 02\n}\n\n// from the current swap inputs, compute the best trade and return it.\nfunction useComputeSwapInfo(): SwapInfo {\n  const { account } = useActiveWeb3React()\n\n  const {\n    independentField,\n    amount,\n    [Field.INPUT]: inputCurrency,\n    [Field.OUTPUT]: outputCurrency,\n  } = useAtomValue(swapAtom)\n\n  const feeOptions = useAtomValue(feeOptionsAtom)\n\n  const to = account\n\n  const relevantTokenBalances = useCurrencyBalances(\n    account,\n    useMemo(() => [inputCurrency ?? undefined, outputCurrency ?? undefined], [inputCurrency, outputCurrency])\n  )\n\n  const isExactIn: boolean = independentField === Field.INPUT\n  const parsedAmount = useMemo(\n    () => tryParseCurrencyAmount(amount, (isExactIn ? inputCurrency : outputCurrency) ?? undefined),\n    [inputCurrency, isExactIn, outputCurrency, amount]\n  )\n\n  //@TODO(ianlapham): this would eventually be replaced with routing api logic.\n  const trade = useBestTrade(\n    isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT,\n    parsedAmount,\n    (isExactIn ? outputCurrency : inputCurrency) ?? undefined\n  )\n\n  const currencies = useMemo(\n    () => ({\n      [Field.INPUT]: inputCurrency ?? undefined,\n      [Field.OUTPUT]: outputCurrency ?? undefined,\n    }),\n    [inputCurrency, outputCurrency]\n  )\n\n  const currencyBalances = useMemo(\n    () => ({\n      [Field.INPUT]: relevantTokenBalances[0],\n      [Field.OUTPUT]: relevantTokenBalances[1],\n    }),\n    [relevantTokenBalances]\n  )\n\n  const currencyAmounts = useMemo(\n    () => ({\n      [Field.INPUT]: trade.trade?.inputAmount,\n      [Field.OUTPUT]: trade.trade?.outputAmount,\n    }),\n    [trade.trade?.inputAmount, trade.trade?.outputAmount]\n  )\n\n  /*\n   * If user has enabled 'auto' slippage, use the default best slippage calculated\n   * based on the trade. If user has entered custom slippage, use that instead.\n   */\n  const autoSlippageTolerance = useAutoSlippageTolerance(trade.trade)\n  const maxSlippage = useAtomValue(maxSlippageAtom)\n  const allowedSlippage = useMemo(\n    () => (maxSlippage === 'auto' ? autoSlippageTolerance : maxSlippage),\n    [autoSlippageTolerance, maxSlippage]\n  )\n\n  const inputError = useMemo(() => {\n    let inputError: ReactNode | undefined\n\n    if (!account) {\n      inputError = <Trans>Connect Wallet</Trans>\n    }\n\n    if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n      inputError = inputError ?? <Trans>Select token</Trans>\n    }\n\n    if (!parsedAmount) {\n      inputError = inputError ?? <Trans>Enter an amount</Trans>\n    }\n\n    const formattedTo = isAddress(to)\n    if (!to || !formattedTo) {\n      inputError = inputError ?? <Trans>Enter a recipient</Trans>\n    } else {\n      if (BAD_RECIPIENT_ADDRESSES[formattedTo]) {\n        inputError = inputError ?? <Trans>Invalid recipient</Trans>\n      }\n    }\n\n    // compare input balance to max input based on version\n    const [balanceIn, amountIn] = [currencyBalances[Field.INPUT], trade.trade?.maximumAmountIn(allowedSlippage)]\n\n    if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n      inputError = <Trans>Insufficient {amountIn.currency.symbol} balance</Trans>\n    }\n\n    return inputError\n  }, [account, allowedSlippage, currencies, currencyBalances, parsedAmount, to, trade.trade])\n\n  return useMemo(\n    () => ({\n      currencies,\n      currencyBalances,\n      currencyAmounts,\n      inputError,\n      trade,\n      allowedSlippage,\n      feeOptions,\n    }),\n    [currencies, currencyBalances, currencyAmounts, inputError, trade, allowedSlippage, feeOptions]\n  )\n}\n\nconst swapInfoAtom = atom<SwapInfo>({\n  currencies: {},\n  currencyBalances: {},\n  currencyAmounts: {},\n  trade: { state: TradeState.INVALID },\n  allowedSlippage: new Percent(0),\n  feeOptions: undefined,\n})\n\nexport function SwapInfoUpdater() {\n  const setSwapInfo = useUpdateAtom(swapInfoAtom)\n  const swapInfo = useComputeSwapInfo()\n  useEffect(() => {\n    setSwapInfo(swapInfo)\n  }, [swapInfo, setSwapInfo])\n  return null\n}\n\n/** Requires that SwapInfoUpdater be installed in the DOM tree. **/\nexport default function useSwapInfo(): SwapInfo {\n  return useAtomValue(swapInfoAtom)\n}\n","import { Protocol } from '@uniswap/router-sdk'\nimport { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { useStablecoinAmountFromFiatValue } from 'hooks/useUSDCPrice'\nimport { useEffect, useMemo, useState } from 'react'\nimport { GetQuoteResult, InterfaceTrade, TradeState } from 'state/routing/types'\nimport { computeRoutes, transformRoutesToTrade } from 'state/routing/utils'\n\nimport useActiveWeb3React from '../useActiveWeb3React'\nimport { getClientSideQuote } from './clientSideSmartOrderRouter'\nimport { useRoutingAPIArguments } from './useRoutingAPIArguments'\n\nconst protocols: Protocol[] = [Protocol.V2, Protocol.V3]\nconst config = { protocols }\n\nexport default function useClientSideSmartOrderRouterTrade<TTradeType extends TradeType>(\n  tradeType: TTradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TTradeType> | undefined\n} {\n  const chainId = amountSpecified?.currency.chainId\n  const { library } = useActiveWeb3React()\n\n  const [currencyIn, currencyOut]: [Currency | undefined, Currency | undefined] = useMemo(\n    () =>\n      tradeType === TradeType.EXACT_INPUT\n        ? [amountSpecified?.currency, otherCurrency]\n        : [otherCurrency, amountSpecified?.currency],\n    [amountSpecified, otherCurrency, tradeType]\n  )\n\n  const queryArgs = useRoutingAPIArguments({\n    tokenIn: currencyIn,\n    tokenOut: currencyOut,\n    amount: amountSpecified,\n    tradeType,\n    useClientSideRouter: true,\n  })\n  const params = useMemo(() => chainId && library && { chainId, provider: library }, [chainId, library])\n\n  const [loading, setLoading] = useState(false)\n  const [{ quoteResult, error }, setFetchedResult] = useState<{\n    quoteResult: GetQuoteResult | undefined\n    error: unknown\n  }>({\n    quoteResult: undefined,\n    error: undefined,\n  })\n\n  // When arguments update, make a new call to SOR for updated quote\n  useEffect(() => {\n    setLoading(true)\n    fetchQuote()\n\n    async function fetchQuote() {\n      try {\n        if (queryArgs && params) {\n          const result = await getClientSideQuote(queryArgs, params, config)\n          setFetchedResult({\n            quoteResult: result.data,\n            error: result.error,\n          })\n        }\n      } catch (e) {\n        setFetchedResult({\n          quoteResult: undefined,\n          error: true,\n        })\n      } finally {\n        setLoading(false)\n      }\n    }\n  }, [queryArgs, params])\n\n  const route = useMemo(\n    () => computeRoutes(currencyIn, currencyOut, tradeType, quoteResult),\n    [currencyIn, currencyOut, quoteResult, tradeType]\n  )\n\n  // get USD gas cost of trade in active chains stablecoin amount\n  const gasUseEstimateUSD = useStablecoinAmountFromFiatValue(quoteResult?.gasUseEstimateUSD) ?? null\n\n  return useMemo(() => {\n    if (!currencyIn || !currencyOut) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined,\n      }\n    }\n\n    if (loading && !quoteResult) {\n      // only on first hook render\n      return {\n        state: TradeState.LOADING,\n        trade: undefined,\n      }\n    }\n\n    let otherAmount = undefined\n    if (tradeType === TradeType.EXACT_INPUT && currencyOut && quoteResult) {\n      otherAmount = CurrencyAmount.fromRawAmount(currencyOut, quoteResult.quote)\n    }\n    if (tradeType === TradeType.EXACT_OUTPUT && currencyIn && quoteResult) {\n      otherAmount = CurrencyAmount.fromRawAmount(currencyIn, quoteResult.quote)\n    }\n\n    if (error || !otherAmount || !route || route.length === 0 || !queryArgs) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined,\n      }\n    }\n\n    try {\n      const trade = transformRoutesToTrade(route, tradeType, gasUseEstimateUSD)\n      return {\n        // always return VALID regardless of isFetching status\n        state: TradeState.VALID,\n        trade,\n      }\n    } catch (e) {\n      console.debug('transformRoutesToTrade failed: ', e)\n      return { state: TradeState.INVALID, trade: undefined }\n    }\n  }, [currencyIn, currencyOut, loading, quoteResult, tradeType, error, route, queryArgs, gasUseEstimateUSD])\n}\n","import { TransactionReceipt, TransactionResponse } from '@ethersproject/abstract-provider'\nimport { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { atomWithImmer } from 'jotai/immer'\n\nexport enum TransactionType {\n  APPROVAL,\n  SWAP,\n}\n\ninterface BaseTransactionInfo {\n  type: TransactionType\n  response: TransactionResponse\n}\n\nexport interface ApprovalTransactionInfo extends BaseTransactionInfo {\n  type: TransactionType.APPROVAL\n  tokenAddress: string\n  spenderAddress: string\n}\n\nexport interface SwapTransactionInfo extends BaseTransactionInfo {\n  type: TransactionType.SWAP\n  tradeType: TradeType\n  inputCurrencyAmount: CurrencyAmount<Currency>\n  outputCurrencyAmount: CurrencyAmount<Currency>\n}\n\nexport interface InputSwapTransactionInfo extends SwapTransactionInfo {\n  tradeType: TradeType.EXACT_INPUT\n  expectedOutputCurrencyAmount: string\n  minimumOutputCurrencyAmount: string\n}\n\nexport interface OutputSwapTransactionInfo extends SwapTransactionInfo {\n  tradeType: TradeType.EXACT_OUTPUT\n  expectedInputCurrencyAmount: string\n  maximumInputCurrencyAmount: string\n}\n\nexport type TransactionInfo = ApprovalTransactionInfo | SwapTransactionInfo\n\nexport interface Transaction<T extends TransactionInfo = TransactionInfo> {\n  addedTime: number\n  lastCheckedBlockNumber?: number\n  receipt?: TransactionReceipt\n  info: T\n}\n\nexport const transactionsAtom = atomWithImmer<{\n  [chainId: string]: { [hash: string]: Transaction }\n}>({})\n","import { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { useClientSideV3Trade } from 'hooks/useClientSideV3Trade'\nimport useDebounce from 'hooks/useDebounce'\nimport { useMemo } from 'react'\nimport { InterfaceTrade, TradeState } from 'state/routing/types'\n\nimport useClientSideSmartOrderRouterTrade from '../routing/useClientSideSmartOrderRouterTrade'\n\n/**\n * Returns the currency amount from independent field, currency from independent field,\n * and currency from dependent field.\n */\nfunction getTradeInputs(\n  trade: InterfaceTrade<Currency, Currency, TradeType> | undefined,\n  tradeType: TradeType\n): [CurrencyAmount<Currency> | undefined, Currency | undefined, Currency | undefined] {\n  if (trade) {\n    if (tradeType === TradeType.EXACT_INPUT) {\n      return [trade.inputAmount, trade.inputAmount.currency, trade.outputAmount.currency]\n    }\n    if (tradeType === TradeType.EXACT_OUTPUT) {\n      return [trade.outputAmount, trade.outputAmount.currency, trade.inputAmount.currency]\n    }\n  }\n  return [undefined, undefined, undefined]\n}\n\ninterface TradeDebouncingParams {\n  amounts: [CurrencyAmount<Currency> | undefined, CurrencyAmount<Currency> | undefined]\n  indepdenentCurrencies: [Currency | undefined, Currency | undefined]\n  dependentCurrencies: [Currency | undefined, Currency | undefined]\n}\n\n/**\n * Returns wether debounced values are stale compared to latest values from trade.\n */\nfunction isTradeDebouncing({ amounts, indepdenentCurrencies, dependentCurrencies }: TradeDebouncingParams): boolean {\n  // Ensure that amount from user input matches latest trade.\n  const amountsMatch = amounts[0] && amounts[1]?.equalTo(amounts[0])\n\n  // Ensure active swap currencies match latest trade.\n  const currenciesMatch =\n    indepdenentCurrencies[0] &&\n    indepdenentCurrencies[1]?.equals(indepdenentCurrencies[0]) &&\n    dependentCurrencies[0] &&\n    dependentCurrencies[1]?.equals(dependentCurrencies[0])\n\n  return !amountsMatch || !currenciesMatch\n}\n\n/**\n * Returns the best v2+v3 trade for a desired swap.\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\nexport function useBestTrade(\n  tradeType: TradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TradeType> | undefined\n} {\n  // Debounce is used to prevent excessive requests to SOR, as it is data intensive.\n  // This helps provide a \"syncing\" state the UI can reference for loading animations.\n  const [debouncedAmount, debouncedOtherCurrency] = useDebounce(\n    useMemo(() => [amountSpecified, otherCurrency], [amountSpecified, otherCurrency]),\n    200\n  )\n\n  const clientSORTrade = useClientSideSmartOrderRouterTrade(tradeType, debouncedAmount, debouncedOtherCurrency)\n\n  const [amountFromLatestTrade, currencyFromTrade, otherCurrencyFromTrade] = getTradeInputs(\n    clientSORTrade.trade,\n    tradeType\n  )\n\n  const debouncing =\n    (amountSpecified && debouncedAmount && amountSpecified !== debouncedAmount) ||\n    (amountSpecified && debouncedOtherCurrency && otherCurrency && debouncedOtherCurrency !== otherCurrency)\n\n  const syncing =\n    amountSpecified &&\n    isTradeDebouncing({\n      amounts: [amountFromLatestTrade, amountSpecified],\n      indepdenentCurrencies: [currencyFromTrade, amountSpecified?.currency],\n      dependentCurrencies: [otherCurrencyFromTrade, debouncedOtherCurrency],\n    })\n\n  const useFallback = !syncing && clientSORTrade.state === TradeState.NO_ROUTE_FOUND\n\n  // Use a simple client side logic as backup if SOR is not available.\n  const fallbackTrade = useClientSideV3Trade(\n    tradeType,\n    useFallback ? debouncedAmount : undefined,\n    useFallback ? debouncedOtherCurrency : undefined\n  )\n\n  return useMemo(\n    () => ({\n      ...(useFallback ? fallbackTrade : clientSORTrade),\n      ...(syncing ? { state: TradeState.SYNCING } : {}),\n      ...(debouncing ? { state: TradeState.LOADING } : {}),\n    }),\n    [debouncing, fallbackTrade, syncing, clientSORTrade, useFallback]\n  )\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { L2_CHAIN_IDS } from 'constants/chains'\nimport { DEFAULT_DEADLINE_FROM_NOW, L2_DEADLINE_FROM_NOW } from 'constants/misc'\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp'\nimport { useAtom } from 'jotai'\nimport { transactionTtlAtom } from 'lib/state/settings'\nimport { useMemo } from 'react'\n\nimport useActiveWeb3React from './useActiveWeb3React'\n\n/** Returns the default transaction TTL for the chain, in minutes. */\nexport function useDefaultTransactionTtl(): number {\n  const { chainId } = useActiveWeb3React()\n  if (chainId && L2_CHAIN_IDS.includes(chainId)) return L2_DEADLINE_FROM_NOW / 60\n  return DEFAULT_DEADLINE_FROM_NOW / 60\n}\n\n/** Returns the user-inputted transaction TTL, in minutes. */\nexport function useTransactionTtl(): [number | undefined, (ttl?: number) => void] {\n  return useAtom(transactionTtlAtom)\n}\n\n// combines the block timestamp with the user setting to give the deadline that should be used for any submitted transaction\nexport default function useTransactionDeadline(): BigNumber | undefined {\n  const [ttl] = useTransactionTtl()\n  const defaultTtl = useDefaultTransactionTtl()\n\n  const blockTimestamp = useCurrentBlockTimestamp()\n  return useMemo(() => {\n    if (!blockTimestamp) return undefined\n    return blockTimestamp.add((ttl || defaultTtl) /* in seconds */ * 60)\n  }, [blockTimestamp, defaultTtl, ttl])\n}\n","import { Trans } from '@lingui/macro'\nimport { Token, TradeType } from '@uniswap/sdk-core'\nimport { CHAIN_INFO } from 'constants/chainInfo'\nimport { useERC20PermitFromTrade } from 'hooks/useERC20Permit'\nimport { useUpdateAtom } from 'jotai/utils'\nimport { useAtomValue } from 'jotai/utils'\nimport { useSwapInfo } from 'lib/hooks/swap'\nimport useSwapApproval, {\n  ApprovalState,\n  useSwapApprovalOptimizedTrade,\n  useSwapRouterAddress,\n} from 'lib/hooks/swap/useSwapApproval'\nimport { useSwapCallback } from 'lib/hooks/swap/useSwapCallback'\nimport { useAddTransaction } from 'lib/hooks/transactions'\nimport { usePendingApproval } from 'lib/hooks/transactions'\nimport useActiveWeb3React from 'lib/hooks/useActiveWeb3React'\nimport useTransactionDeadline from 'lib/hooks/useTransactionDeadline'\nimport { Link, Spinner } from 'lib/icons'\nimport { displayTxHashAtom, Field, independentFieldAtom } from 'lib/state/swap'\nimport { TransactionType } from 'lib/state/transactions'\nimport styled, { useTheme } from 'lib/theme'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\nimport invariant from 'tiny-invariant'\n\nimport ActionButton from '../ActionButton'\nimport Dialog from '../Dialog'\nimport Row from '../Row'\nimport { SummaryDialog } from './Summary'\n\ninterface SwapButtonProps {\n  disabled?: boolean\n}\n\nconst EtherscanA = styled.a`\n  color: currentColor;\n  text-decoration: none;\n`\n\nfunction useIsPendingApproval(token?: Token, spender?: string): boolean {\n  return Boolean(usePendingApproval(token, spender))\n}\n\nexport default function SwapButton({ disabled }: SwapButtonProps) {\n  const { account, chainId } = useActiveWeb3React()\n\n  const { tokenColorExtraction } = useTheme()\n\n  const {\n    trade,\n    allowedSlippage,\n    currencies: { [Field.INPUT]: inputCurrency },\n    currencyBalances: { [Field.INPUT]: inputCurrencyBalance },\n    currencyAmounts: { [Field.INPUT]: inputCurrencyAmount, [Field.OUTPUT]: outputCurrencyAmount },\n    feeOptions,\n  } = useSwapInfo()\n\n  const independentField = useAtomValue(independentFieldAtom)\n\n  const [activeTrade, setActiveTrade] = useState<typeof trade.trade | undefined>()\n  useEffect(() => {\n    setActiveTrade((activeTrade) => activeTrade && trade.trade)\n  }, [trade])\n\n  // TODO(zzmp): Return an optimized trade directly from useSwapInfo.\n  const optimizedTrade =\n    // Use trade.trade if there is no swap optimized trade. This occurs if approvals are still pending.\n    useSwapApprovalOptimizedTrade(trade.trade, allowedSlippage, useIsPendingApproval) || trade.trade\n  const [approval, getApproval] = useSwapApproval(optimizedTrade, allowedSlippage, useIsPendingApproval)\n  const approvalHash = usePendingApproval(\n    inputCurrency?.isToken ? inputCurrency : undefined,\n    useSwapRouterAddress(optimizedTrade)\n  )\n\n  const addTransaction = useAddTransaction()\n  const addApprovalTransaction = useCallback(() => {\n    getApproval().then((transaction) => {\n      if (transaction) {\n        addTransaction({ type: TransactionType.APPROVAL, ...transaction })\n      }\n    })\n  }, [addTransaction, getApproval])\n\n  const actionProps = useMemo(() => {\n    if (disabled) return { disabled: true }\n\n    if (chainId && inputCurrencyAmount && inputCurrencyBalance?.greaterThan(inputCurrencyAmount)) {\n      if (approval === ApprovalState.PENDING) {\n        return {\n          disabled: true,\n          update: {\n            message: (\n              <EtherscanA href={approvalHash && `${CHAIN_INFO[chainId].explorer}tx/${approvalHash}`} target=\"_blank\">\n                <Row gap={0.25}>\n                  <Trans>\n                    Approval pending <Link />\n                  </Trans>\n                </Row>\n              </EtherscanA>\n            ),\n            action: <Trans>Approve</Trans>,\n            icon: Spinner,\n          },\n        }\n      } else if (approval === ApprovalState.NOT_APPROVED) {\n        return {\n          update: {\n            message: <Trans>Approve {inputCurrencyAmount.currency.symbol} first</Trans>,\n            action: <Trans>Approve</Trans>,\n          },\n        }\n      }\n      return {}\n    }\n\n    return { disabled: true }\n  }, [approval, approvalHash, chainId, disabled, inputCurrencyAmount, inputCurrencyBalance])\n\n  const deadline = useTransactionDeadline()\n  const { signatureData } = useERC20PermitFromTrade(optimizedTrade, allowedSlippage, deadline)\n\n  // the callback to execute the swap\n  const { callback: swapCallback } = useSwapCallback({\n    trade: optimizedTrade,\n    allowedSlippage,\n    recipientAddressOrName: account ?? null,\n    signatureData,\n    deadline,\n    feeOptions,\n  })\n\n  //@TODO(ianlapham): add a loading state, process errors\n  const setDisplayTxHash = useUpdateAtom(displayTxHashAtom)\n\n  const onConfirm = useCallback(() => {\n    swapCallback?.()\n      .then((response) => {\n        setDisplayTxHash(response.hash)\n        invariant(inputCurrencyAmount && outputCurrencyAmount)\n        addTransaction({\n          response,\n          type: TransactionType.SWAP,\n          tradeType: independentField === Field.INPUT ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT,\n          inputCurrencyAmount,\n          outputCurrencyAmount,\n        })\n      })\n      .catch((error) => {\n        //@TODO(ianlapham): add error handling\n        console.log(error)\n      })\n      .finally(() => {\n        setActiveTrade(undefined)\n      })\n  }, [addTransaction, independentField, inputCurrencyAmount, outputCurrencyAmount, setDisplayTxHash, swapCallback])\n\n  return (\n    <>\n      <ActionButton\n        color={tokenColorExtraction ? 'interactive' : 'accent'}\n        onClick={() => setActiveTrade(trade.trade)}\n        onUpdate={addApprovalTransaction}\n        {...actionProps}\n      >\n        <Trans>Review swap</Trans>\n      </ActionButton>\n      {activeTrade && (\n        <Dialog color=\"dialog\" onClose={() => setActiveTrade(undefined)}>\n          <SummaryDialog trade={activeTrade} allowedSlippage={allowedSlippage} onConfirm={onConfirm} />\n        </Dialog>\n      )}\n    </>\n  )\n}\n"],"sourceRoot":""}