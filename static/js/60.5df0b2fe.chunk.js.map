{"version":3,"sources":["lib/state/swap.ts","lib/state/atoms.ts","lib/state/settings.ts","lib/hooks/swap/useSwapInfo.tsx","lib/hooks/routing/useClientSideSmartOrderRouterTrade.ts","lib/hooks/useAllowedSlippage.ts","lib/hooks/swap/useBestTrade.ts"],"names":["Field","swapAtom","atomWithImmer","independentField","INPUT","amount","nativeOnChain","SupportedChainId","AVALANCHE","independentFieldAtom","pickAtom","displayTxHashAtom","atom","undefined","feeOptionsAtom","anAtom","key","setter","draft","update","get","set","withImmer","value","derived","setTogglable","MAX_VALID_SLIPPAGE","Percent","MIN_HIGH_SLIPPAGE","initialSettings","autoSlippage","maxSlippage","transactionTtl","mockTogglable","clientSideRouter","settingsAtom","atomWithReset","autoSlippageAtom","maxSlippageAtom","transactionTtlAtom","mockTogglableAtom","clientSideRouterAtom","BAD_RECIPIENT_ADDRESSES","swapInfoAtom","currencies","currencyBalances","currencyAmounts","trade","state","TradeState","INVALID","allowedSlippage","feeOptions","SwapInfoUpdater","setSwapInfo","useUpdateAtom","swapInfo","account","useActiveWeb3React","useAtomValue","inputCurrency","outputCurrency","OUTPUT","to","relevantTokenBalances","useCurrencyBalances","useMemo","isExactIn","parsedAmount","tryParseCurrencyAmount","useBestTrade","TradeType","EXACT_INPUT","EXACT_OUTPUT","inputAmount","outputAmount","useAllowedSlippage","inputError","formattedTo","isAddress","maximumAmountIn","balanceIn","amountIn","lessThan","currency","symbol","useComputeSwapInfo","useEffect","useSwapInfo","config","protocols","Protocol","V2","V3","useClientSideSmartOrderRouterTrade","tradeType","amountSpecified","otherCurrency","chainId","library","currencyIn","currencyOut","queryArgs","useRoutingAPIArguments","tokenIn","tokenOut","useClientSideRouter","params","provider","useState","loading","setLoading","quoteResult","error","setFetchedResult","a","getClientSideQuote","result","data","fetchQuote","route","computeRoutes","gasUseEstimateUSD","useStablecoinAmountFromFiatValue","LOADING","otherAmount","CurrencyAmount","fromRawAmount","quote","length","NO_ROUTE_FOUND","transformRoutesToTrade","VALID","e","console","debug","toPercent","numerator","Math","floor","useMaxSlippage","useAutoSlippageTolerance","useDebounce","debouncedAmount","debouncedOtherCurrency","clientSORTrade","getTradeInputs","amountFromLatestTrade","currencyFromTrade","otherCurrencyFromTrade","debouncing","syncing","amounts","indepdenentCurrencies","dependentCurrencies","amountsMatch","equalTo","currenciesMatch","equals","isTradeDebouncing","useFallback","fallbackTrade","useClientSideV3Trade","SYNCING"],"mappings":"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","file":"static/js/60.5df0b2fe.chunk.js","sourcesContent":["import { Currency } from '@uniswap/sdk-core'\nimport { FeeOptions } from '@uniswap/v3-sdk'\nimport { SupportedChainId } from 'constants/chains'\nimport { nativeOnChain } from 'constants/tokens'\nimport { atom } from 'jotai'\nimport { atomWithImmer } from 'jotai/immer'\nimport { pickAtom } from 'lib/state/atoms'\n\nexport enum Field {\n  INPUT = 'INPUT',\n  OUTPUT = 'OUTPUT',\n}\n\nexport interface Swap {\n  independentField: Field\n  amount: string\n  [Field.INPUT]?: Currency\n  [Field.OUTPUT]?: Currency\n}\n\nexport const swapAtom = atomWithImmer<Swap>({\n  independentField: Field.INPUT,\n  amount: '',\n  [Field.INPUT]: nativeOnChain(SupportedChainId.AVALANCHE),\n})\n\nexport const independentFieldAtom = pickAtom(swapAtom, 'independentField')\n\n// If set to a transaction hash, that transaction will display in a status dialog.\nexport const displayTxHashAtom = atom<string | undefined>(undefined)\n\nexport const feeOptionsAtom = atom<FeeOptions | undefined>(undefined)\n","/* eslint-disable @typescript-eslint/ban-types */\nimport { Draft } from 'immer'\nimport { atom, WritableAtom } from 'jotai'\nimport { withImmer } from 'jotai/immer'\n\n/**\n * Creates a derived atom whose value is the picked object property.\n * By default, the setter acts as a primitive atom's, changing the original atom.\n * A custom setter may also be passed, which uses an Immer Draft so that it may be mutated directly.\n */\nexport function pickAtom<Value, Key extends keyof Value & keyof Draft<Value>, Update>(\n  anAtom: WritableAtom<Value, Value>,\n  key: Key,\n  setter: (draft: Draft<Value>[Key], update: Update) => Draft<Value>[Key]\n): WritableAtom<Value[Key], Update>\nexport function pickAtom<Value, Key extends keyof Value & keyof Draft<Value>, Update extends Value[Key]>(\n  anAtom: WritableAtom<Value, Value>,\n  key: Key,\n  setter?: (draft: Draft<Value>[Key], update: Update) => Draft<Value>[Key]\n): WritableAtom<Value[Key], Update>\nexport function pickAtom<Value, Key extends keyof Value & keyof Draft<Value>, Update extends Value[Key]>(\n  anAtom: WritableAtom<Value, Value>,\n  key: Key,\n  setter: (draft: Draft<Value>[Key], update: Update) => Draft<Value>[Key] = (draft, update) =>\n    update as Draft<Value>[Key]\n): WritableAtom<Value[Key], Update> {\n  return atom(\n    (get) => get(anAtom)[key],\n    (get, set, update: Update) =>\n      set(withImmer(anAtom), (value) => {\n        const derived = setter(value[key], update)\n        value[key] = derived\n      })\n  )\n}\n\n/** Sets a togglable atom to invert its state at the next render. */\nexport function setTogglable(draft: boolean) {\n  return !draft\n}\n","import { Percent } from '@uniswap/sdk-core'\nimport { atomWithReset } from 'jotai/utils'\n\nimport { pickAtom, setTogglable } from './atoms'\n\nexport const MAX_VALID_SLIPPAGE = new Percent(1, 2)\nexport const MIN_HIGH_SLIPPAGE = new Percent(1, 100)\n\ninterface Settings {\n  autoSlippage: boolean // if true, slippage will use the default calculation\n  maxSlippage: number | undefined // expressed as a percent\n  transactionTtl: number | undefined\n  mockTogglable: boolean\n  clientSideRouter: boolean // whether to use the client-side router or query the remote API\n}\n\nconst initialSettings: Settings = {\n  autoSlippage: true,\n  maxSlippage: undefined,\n  transactionTtl: undefined,\n  mockTogglable: true,\n  clientSideRouter: true,\n}\n\nexport const settingsAtom = atomWithReset(initialSettings)\nexport const autoSlippageAtom = pickAtom(settingsAtom, 'autoSlippage')\nexport const maxSlippageAtom = pickAtom(settingsAtom, 'maxSlippage')\nexport const transactionTtlAtom = pickAtom(settingsAtom, 'transactionTtl')\nexport const mockTogglableAtom = pickAtom(settingsAtom, 'mockTogglable', setTogglable)\nexport const clientSideRouterAtom = pickAtom(settingsAtom, 'clientSideRouter')\n","import { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Percent, TradeType } from '@uniswap/sdk-core'\nimport { FeeOptions } from '@uniswap/v3-sdk'\nimport { atom } from 'jotai'\nimport { useAtomValue, useUpdateAtom } from 'jotai/utils'\nimport { useCurrencyBalances } from 'lib/hooks/useCurrencyBalance'\nimport { feeOptionsAtom, Field, swapAtom } from 'lib/state/swap'\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount'\nimport { ReactNode, useEffect, useMemo } from 'react'\nimport { InterfaceTrade, TradeState } from 'state/routing/types'\n\nimport { isAddress } from '../../../utils'\nimport useActiveWeb3React from '../useActiveWeb3React'\nimport useAllowedSlippage from '../useAllowedSlippage'\nimport { useBestTrade } from './useBestTrade'\n\ninterface SwapInfo {\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  currencyAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  trade: {\n    trade?: InterfaceTrade<Currency, Currency, TradeType>\n    state: TradeState\n  }\n  allowedSlippage: Percent\n  feeOptions: FeeOptions | undefined\n}\n\nconst BAD_RECIPIENT_ADDRESSES: { [address: string]: true } = {\n  '0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10': true, // v2 factory\n  '0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106': true, // v2 router 01\n  '0x60aE616a2155Ee3d9A68541Ba4544862310933d4': true, // v2 router 02\n}\n\n// from the current swap inputs, compute the best trade and return it.\nfunction useComputeSwapInfo(): SwapInfo {\n  const { account } = useActiveWeb3React()\n\n  const {\n    independentField,\n    amount,\n    [Field.INPUT]: inputCurrency,\n    [Field.OUTPUT]: outputCurrency,\n  } = useAtomValue(swapAtom)\n\n  const feeOptions = useAtomValue(feeOptionsAtom)\n\n  const to = account\n\n  const relevantTokenBalances = useCurrencyBalances(\n    account,\n    useMemo(() => [inputCurrency ?? undefined, outputCurrency ?? undefined], [inputCurrency, outputCurrency])\n  )\n\n  const isExactIn: boolean = independentField === Field.INPUT\n  const parsedAmount = useMemo(\n    () => tryParseCurrencyAmount(amount, (isExactIn ? inputCurrency : outputCurrency) ?? undefined),\n    [inputCurrency, isExactIn, outputCurrency, amount]\n  )\n\n  //@TODO(ianlapham): this would eventually be replaced with routing api logic.\n  const trade = useBestTrade(\n    isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT,\n    parsedAmount,\n    (isExactIn ? outputCurrency : inputCurrency) ?? undefined\n  )\n\n  const currencies = useMemo(\n    () => ({\n      [Field.INPUT]: inputCurrency ?? undefined,\n      [Field.OUTPUT]: outputCurrency ?? undefined,\n    }),\n    [inputCurrency, outputCurrency]\n  )\n\n  const currencyBalances = useMemo(\n    () => ({\n      [Field.INPUT]: relevantTokenBalances[0],\n      [Field.OUTPUT]: relevantTokenBalances[1],\n    }),\n    [relevantTokenBalances]\n  )\n\n  const currencyAmounts = useMemo(\n    () => ({\n      [Field.INPUT]: trade.trade?.inputAmount,\n      [Field.OUTPUT]: trade.trade?.outputAmount,\n    }),\n    [trade.trade?.inputAmount, trade.trade?.outputAmount]\n  )\n\n  const allowedSlippage = useAllowedSlippage(trade.trade)\n\n  const inputError = useMemo(() => {\n    let inputError: ReactNode | undefined\n\n    if (!account) {\n      inputError = <Trans>Connect Wallet</Trans>\n    }\n\n    if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n      inputError = inputError ?? <Trans>Select token</Trans>\n    }\n\n    if (!parsedAmount) {\n      inputError = inputError ?? <Trans>Enter an amount</Trans>\n    }\n\n    const formattedTo = isAddress(to)\n    if (!to || !formattedTo) {\n      inputError = inputError ?? <Trans>Enter a recipient</Trans>\n    } else {\n      if (BAD_RECIPIENT_ADDRESSES[formattedTo]) {\n        inputError = inputError ?? <Trans>Invalid recipient</Trans>\n      }\n    }\n\n    // compare input balance to max input based on version\n    const [balanceIn, amountIn] = [currencyBalances[Field.INPUT], trade.trade?.maximumAmountIn(allowedSlippage)]\n\n    if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n      inputError = <Trans>Insufficient {amountIn.currency.symbol} balance</Trans>\n    }\n\n    return inputError\n  }, [account, allowedSlippage, currencies, currencyBalances, parsedAmount, to, trade.trade])\n\n  return useMemo(\n    () => ({\n      currencies,\n      currencyBalances,\n      currencyAmounts,\n      inputError,\n      trade,\n      allowedSlippage,\n      feeOptions,\n    }),\n    [currencies, currencyBalances, currencyAmounts, inputError, trade, allowedSlippage, feeOptions]\n  )\n}\n\nconst swapInfoAtom = atom<SwapInfo>({\n  currencies: {},\n  currencyBalances: {},\n  currencyAmounts: {},\n  trade: { state: TradeState.INVALID },\n  allowedSlippage: new Percent(0),\n  feeOptions: undefined,\n})\n\nexport function SwapInfoUpdater() {\n  const setSwapInfo = useUpdateAtom(swapInfoAtom)\n  const swapInfo = useComputeSwapInfo()\n  useEffect(() => {\n    setSwapInfo(swapInfo)\n  }, [swapInfo, setSwapInfo])\n  return null\n}\n\n/** Requires that SwapInfoUpdater be installed in the DOM tree. **/\nexport default function useSwapInfo(): SwapInfo {\n  return useAtomValue(swapInfoAtom)\n}\n","import { Protocol } from '@uniswap/router-sdk'\nimport { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { useStablecoinAmountFromFiatValue } from 'hooks/useUSDCPrice'\nimport { useEffect, useMemo, useState } from 'react'\nimport { GetQuoteResult, InterfaceTrade, TradeState } from 'state/routing/types'\nimport { computeRoutes, transformRoutesToTrade } from 'state/routing/utils'\n\nimport useActiveWeb3React from '../useActiveWeb3React'\nimport { getClientSideQuote } from './clientSideSmartOrderRouter'\nimport { useRoutingAPIArguments } from './useRoutingAPIArguments'\n\nconst protocols: Protocol[] = [Protocol.V2, Protocol.V3]\nconst config = { protocols }\n\nexport default function useClientSideSmartOrderRouterTrade<TTradeType extends TradeType>(\n  tradeType: TTradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TTradeType> | undefined\n} {\n  const chainId = amountSpecified?.currency.chainId\n  const { library } = useActiveWeb3React()\n\n  const [currencyIn, currencyOut]: [Currency | undefined, Currency | undefined] = useMemo(\n    () =>\n      tradeType === TradeType.EXACT_INPUT\n        ? [amountSpecified?.currency, otherCurrency]\n        : [otherCurrency, amountSpecified?.currency],\n    [amountSpecified, otherCurrency, tradeType]\n  )\n\n  const queryArgs = useRoutingAPIArguments({\n    tokenIn: currencyIn,\n    tokenOut: currencyOut,\n    amount: amountSpecified,\n    tradeType,\n    useClientSideRouter: true,\n  })\n  const params = useMemo(() => chainId && library && { chainId, provider: library }, [chainId, library])\n\n  const [loading, setLoading] = useState(false)\n  const [{ quoteResult, error }, setFetchedResult] = useState<{\n    quoteResult: GetQuoteResult | undefined\n    error: unknown\n  }>({\n    quoteResult: undefined,\n    error: undefined,\n  })\n\n  // When arguments update, make a new call to SOR for updated quote\n  useEffect(() => {\n    setLoading(true)\n    fetchQuote()\n\n    async function fetchQuote() {\n      try {\n        if (queryArgs && params) {\n          const result = await getClientSideQuote(queryArgs, params, config)\n          setFetchedResult({\n            quoteResult: result.data,\n            error: result.error,\n          })\n        }\n      } catch (e) {\n        setFetchedResult({\n          quoteResult: undefined,\n          error: true,\n        })\n      } finally {\n        setLoading(false)\n      }\n    }\n  }, [queryArgs, params])\n\n  const route = useMemo(\n    () => computeRoutes(currencyIn, currencyOut, tradeType, quoteResult),\n    [currencyIn, currencyOut, quoteResult, tradeType]\n  )\n\n  // get USD gas cost of trade in active chains stablecoin amount\n  const gasUseEstimateUSD = useStablecoinAmountFromFiatValue(quoteResult?.gasUseEstimateUSD) ?? null\n\n  return useMemo(() => {\n    if (!currencyIn || !currencyOut) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined,\n      }\n    }\n\n    if (loading && !quoteResult) {\n      // only on first hook render\n      return {\n        state: TradeState.LOADING,\n        trade: undefined,\n      }\n    }\n\n    let otherAmount = undefined\n    if (tradeType === TradeType.EXACT_INPUT && currencyOut && quoteResult) {\n      otherAmount = CurrencyAmount.fromRawAmount(currencyOut, quoteResult.quote)\n    }\n    if (tradeType === TradeType.EXACT_OUTPUT && currencyIn && quoteResult) {\n      otherAmount = CurrencyAmount.fromRawAmount(currencyIn, quoteResult.quote)\n    }\n\n    if (error || !otherAmount || !route || route.length === 0 || !queryArgs) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined,\n      }\n    }\n\n    try {\n      const trade = transformRoutesToTrade(route, tradeType, gasUseEstimateUSD)\n      return {\n        // always return VALID regardless of isFetching status\n        state: TradeState.VALID,\n        trade,\n      }\n    } catch (e) {\n      console.debug('transformRoutesToTrade failed: ', e)\n      return { state: TradeState.INVALID, trade: undefined }\n    }\n  }, [currencyIn, currencyOut, loading, quoteResult, tradeType, error, route, queryArgs, gasUseEstimateUSD])\n}\n","import { Currency, Percent, TradeType } from '@uniswap/sdk-core'\nimport useAutoSlippageTolerance from 'hooks/useAutoSlippageTolerance'\nimport { useAtomValue } from 'jotai/utils'\nimport { autoSlippageAtom, maxSlippageAtom } from 'lib/state/settings'\nimport { InterfaceTrade } from 'state/routing/types'\n\nexport function toPercent(maxSlippage: number | undefined): Percent | undefined {\n  if (!maxSlippage) return undefined\n  const numerator = Math.floor(maxSlippage * 100)\n  return new Percent(numerator, 10_000)\n}\n\n/** Returns the user-inputted max slippage. */\nexport default function useMaxSlippage(trade: InterfaceTrade<Currency, Currency, TradeType> | undefined): Percent {\n  const autoSlippage = useAutoSlippageTolerance(trade)\n  const maxSlippage = toPercent(useAtomValue(maxSlippageAtom))\n  return useAtomValue(autoSlippageAtom) ? autoSlippage : maxSlippage ?? autoSlippage\n}\n","import { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { useClientSideV3Trade } from 'hooks/useClientSideV3Trade'\nimport useDebounce from 'hooks/useDebounce'\nimport { useMemo } from 'react'\nimport { InterfaceTrade, TradeState } from 'state/routing/types'\n\nimport useClientSideSmartOrderRouterTrade from '../routing/useClientSideSmartOrderRouterTrade'\n\n/**\n * Returns the currency amount from independent field, currency from independent field,\n * and currency from dependent field.\n */\nfunction getTradeInputs(\n  trade: InterfaceTrade<Currency, Currency, TradeType> | undefined,\n  tradeType: TradeType\n): [CurrencyAmount<Currency> | undefined, Currency | undefined, Currency | undefined] {\n  if (trade) {\n    if (tradeType === TradeType.EXACT_INPUT) {\n      return [trade.inputAmount, trade.inputAmount.currency, trade.outputAmount.currency]\n    }\n    if (tradeType === TradeType.EXACT_OUTPUT) {\n      return [trade.outputAmount, trade.outputAmount.currency, trade.inputAmount.currency]\n    }\n  }\n  return [undefined, undefined, undefined]\n}\n\ninterface TradeDebouncingParams {\n  amounts: [CurrencyAmount<Currency> | undefined, CurrencyAmount<Currency> | undefined]\n  indepdenentCurrencies: [Currency | undefined, Currency | undefined]\n  dependentCurrencies: [Currency | undefined, Currency | undefined]\n}\n\n/**\n * Returns wether debounced values are stale compared to latest values from trade.\n */\nfunction isTradeDebouncing({ amounts, indepdenentCurrencies, dependentCurrencies }: TradeDebouncingParams): boolean {\n  // Ensure that amount from user input matches latest trade.\n  const amountsMatch = amounts[0] && amounts[1]?.equalTo(amounts[0])\n\n  // Ensure active swap currencies match latest trade.\n  const currenciesMatch =\n    indepdenentCurrencies[0] &&\n    indepdenentCurrencies[1]?.equals(indepdenentCurrencies[0]) &&\n    dependentCurrencies[0] &&\n    dependentCurrencies[1]?.equals(dependentCurrencies[0])\n\n  return !amountsMatch || !currenciesMatch\n}\n\n/**\n * Returns the best v2+v3 trade for a desired swap.\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\nexport function useBestTrade(\n  tradeType: TradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TradeType> | undefined\n} {\n  // Debounce is used to prevent excessive requests to SOR, as it is data intensive.\n  // This helps provide a \"syncing\" state the UI can reference for loading animations.\n  const [debouncedAmount, debouncedOtherCurrency] = useDebounce(\n    useMemo(() => [amountSpecified, otherCurrency], [amountSpecified, otherCurrency]),\n    200\n  )\n\n  const clientSORTrade = useClientSideSmartOrderRouterTrade(tradeType, debouncedAmount, debouncedOtherCurrency)\n\n  const [amountFromLatestTrade, currencyFromTrade, otherCurrencyFromTrade] = getTradeInputs(\n    clientSORTrade.trade,\n    tradeType\n  )\n\n  const debouncing =\n    (amountSpecified && debouncedAmount && amountSpecified !== debouncedAmount) ||\n    (amountSpecified && debouncedOtherCurrency && otherCurrency && debouncedOtherCurrency !== otherCurrency)\n\n  const syncing =\n    amountSpecified &&\n    isTradeDebouncing({\n      amounts: [amountFromLatestTrade, amountSpecified],\n      indepdenentCurrencies: [currencyFromTrade, amountSpecified?.currency],\n      dependentCurrencies: [otherCurrencyFromTrade, debouncedOtherCurrency],\n    })\n\n  const useFallback = !syncing && clientSORTrade.state === TradeState.NO_ROUTE_FOUND\n\n  // Use a simple client side logic as backup if SOR is not available.\n  const fallbackTrade = useClientSideV3Trade(\n    tradeType,\n    useFallback ? debouncedAmount : undefined,\n    useFallback ? debouncedOtherCurrency : undefined\n  )\n\n  return useMemo(\n    () => ({\n      ...(useFallback ? fallbackTrade : clientSORTrade),\n      ...(syncing ? { state: TradeState.SYNCING } : {}),\n      ...(debouncing ? { state: TradeState.LOADING } : {}),\n    }),\n    [debouncing, fallbackTrade, syncing, clientSORTrade, useFallback]\n  )\n}\n"],"sourceRoot":""}