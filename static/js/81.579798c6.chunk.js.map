{"version":3,"sources":["lib/hooks/routing/useClientSideSmartOrderRouterTrade.ts"],"names":["config","protocols","Protocol","V2","V3","useClientSideSmartOrderRouterTrade","tradeType","amountSpecified","otherCurrency","chainId","currency","library","useActiveWeb3React","useMemo","TradeType","EXACT_INPUT","currencyIn","currencyOut","queryArgs","useRoutingAPIArguments","tokenIn","tokenOut","amount","useClientSideRouter","params","provider","useState","loading","setLoading","quoteResult","undefined","error","setFetchedResult","useEffect","a","getClientSideQuote","result","data","fetchQuote","route","computeRoutes","gasUseEstimateUSD","useStablecoinAmountFromFiatValue","state","TradeState","INVALID","trade","LOADING","otherAmount","CurrencyAmount","fromRawAmount","quote","EXACT_OUTPUT","length","NO_ROUTE_FOUND","transformRoutesToTrade","VALID","e","console","debug"],"mappings":"4RAYMA,EAAS,CAAEC,UADa,CAACC,WAASC,GAAID,WAASE,KAGtC,SAASC,EACtBC,EACAC,EACAC,GAIC,IAAD,EACMC,EAAO,OAAGF,QAAH,IAAGA,OAAH,EAAGA,EAAiBG,SAASD,QAClCE,EAAYC,oBAAZD,QAER,EAAgFE,mBAC9E,kBACEP,IAAcQ,YAAUC,YACpB,QAACR,QAAD,IAACA,OAAD,EAACA,EAAiBG,SAAUF,GAC5B,CAACA,EAAD,OAAgBD,QAAhB,IAAgBA,OAAhB,EAAgBA,EAAiBG,YACvC,CAACH,EAAiBC,EAAeF,IALnC,mBAAOU,EAAP,KAAmBC,EAAnB,KAQMC,EAAYC,iCAAuB,CACvCC,QAASJ,EACTK,SAAUJ,EACVK,OAAQf,EACRD,YACAiB,qBAAqB,IAEjBC,EAASX,mBAAQ,kBAAMJ,GAAWE,GAAW,CAAEF,UAASgB,SAAUd,KAAW,CAACF,EAASE,IAE7F,EAA8Be,oBAAS,GAAvC,mBAAOC,EAAP,KAAgBC,EAAhB,KACA,EAAmDF,mBAGhD,CACDG,iBAAaC,EACbC,WAAOD,IALT,0BAASD,EAAT,EAASA,YAAaE,EAAtB,EAAsBA,MAASC,EAA/B,KASAC,qBAAU,WAAM,4CAId,4BAAAC,EAAA,mEAEQhB,IAAaM,EAFrB,gCAG2BW,6BAAmBjB,EAAWM,EAAQxB,GAHjE,OAGYoC,EAHZ,OAIMJ,EAAiB,CACfH,YAAaO,EAAOC,KACpBN,MAAOK,EAAOL,QANtB,uDAUIC,EAAiB,CACfH,iBAAaC,EACbC,OAAO,IAZb,yBAeIH,GAAW,GAff,6EAJc,sBACdA,GAAW,GADG,mCAEdU,KAoBC,CAACpB,EAAWM,IAEf,IAAMe,EAAQ1B,mBACZ,kBAAM2B,YAAcxB,EAAYC,EAAaX,EAAWuB,KACxD,CAACb,EAAYC,EAAaY,EAAavB,IAInCmC,EAAiB,UAAGC,YAAgC,OAACb,QAAD,IAACA,OAAD,EAACA,EAAaY,0BAAjD,QAAuE,KAE9F,OAAO5B,mBAAQ,WACb,IAAKG,IAAeC,EAClB,MAAO,CACL0B,MAAOC,IAAWC,QAClBC,WAAOhB,GAIX,GAAIH,IAAYE,EAEd,MAAO,CACLc,MAAOC,IAAWG,QAClBD,WAAOhB,GAIX,IAAIkB,OAAclB,EAQlB,GAPIxB,IAAcQ,YAAUC,aAAeE,GAAeY,IACxDmB,EAAcC,iBAAeC,cAAcjC,EAAaY,EAAYsB,QAElE7C,IAAcQ,YAAUsC,cAAgBpC,GAAca,IACxDmB,EAAcC,iBAAeC,cAAclC,EAAYa,EAAYsB,QAGjEpB,IAAUiB,IAAgBT,GAA0B,IAAjBA,EAAMc,SAAiBnC,EAC5D,MAAO,CACLyB,MAAOC,IAAWU,eAClBR,WAAOhB,GAIX,IACE,IAAMgB,EAAQS,YAAuBhB,EAAOjC,EAAWmC,GACvD,MAAO,CAELE,MAAOC,IAAWY,MAClBV,SAEF,MAAOW,GAEP,OADAC,QAAQC,MAAM,kCAAmCF,GAC1C,CAAEd,MAAOC,IAAWC,QAASC,WAAOhB,MAE5C,CAACd,EAAYC,EAAaU,EAASE,EAAavB,EAAWyB,EAAOQ,EAAOrB,EAAWuB","file":"static/js/81.579798c6.chunk.js","sourcesContent":["import { Protocol } from '@uniswap/router-sdk'\nimport { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { useStablecoinAmountFromFiatValue } from 'hooks/useUSDCPrice'\nimport { useEffect, useMemo, useState } from 'react'\nimport { GetQuoteResult, InterfaceTrade, TradeState } from 'state/routing/types'\nimport { computeRoutes, transformRoutesToTrade } from 'state/routing/utils'\n\nimport useActiveWeb3React from '../useActiveWeb3React'\nimport { getClientSideQuote } from './clientSideSmartOrderRouter'\nimport { useRoutingAPIArguments } from './useRoutingAPIArguments'\n\nconst protocols: Protocol[] = [Protocol.V2, Protocol.V3]\nconst config = { protocols }\n\nexport default function useClientSideSmartOrderRouterTrade<TTradeType extends TradeType>(\n  tradeType: TTradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TTradeType> | undefined\n} {\n  const chainId = amountSpecified?.currency.chainId\n  const { library } = useActiveWeb3React()\n\n  const [currencyIn, currencyOut]: [Currency | undefined, Currency | undefined] = useMemo(\n    () =>\n      tradeType === TradeType.EXACT_INPUT\n        ? [amountSpecified?.currency, otherCurrency]\n        : [otherCurrency, amountSpecified?.currency],\n    [amountSpecified, otherCurrency, tradeType]\n  )\n\n  const queryArgs = useRoutingAPIArguments({\n    tokenIn: currencyIn,\n    tokenOut: currencyOut,\n    amount: amountSpecified,\n    tradeType,\n    useClientSideRouter: true,\n  })\n  const params = useMemo(() => chainId && library && { chainId, provider: library }, [chainId, library])\n\n  const [loading, setLoading] = useState(false)\n  const [{ quoteResult, error }, setFetchedResult] = useState<{\n    quoteResult: GetQuoteResult | undefined\n    error: unknown\n  }>({\n    quoteResult: undefined,\n    error: undefined,\n  })\n\n  // When arguments update, make a new call to SOR for updated quote\n  useEffect(() => {\n    setLoading(true)\n    fetchQuote()\n\n    async function fetchQuote() {\n      try {\n        if (queryArgs && params) {\n          const result = await getClientSideQuote(queryArgs, params, config)\n          setFetchedResult({\n            quoteResult: result.data,\n            error: result.error,\n          })\n        }\n      } catch (e) {\n        setFetchedResult({\n          quoteResult: undefined,\n          error: true,\n        })\n      } finally {\n        setLoading(false)\n      }\n    }\n  }, [queryArgs, params])\n\n  const route = useMemo(\n    () => computeRoutes(currencyIn, currencyOut, tradeType, quoteResult),\n    [currencyIn, currencyOut, quoteResult, tradeType]\n  )\n\n  // get USD gas cost of trade in active chains stablecoin amount\n  const gasUseEstimateUSD = useStablecoinAmountFromFiatValue(quoteResult?.gasUseEstimateUSD) ?? null\n\n  return useMemo(() => {\n    if (!currencyIn || !currencyOut) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined,\n      }\n    }\n\n    if (loading && !quoteResult) {\n      // only on first hook render\n      return {\n        state: TradeState.LOADING,\n        trade: undefined,\n      }\n    }\n\n    let otherAmount = undefined\n    if (tradeType === TradeType.EXACT_INPUT && currencyOut && quoteResult) {\n      otherAmount = CurrencyAmount.fromRawAmount(currencyOut, quoteResult.quote)\n    }\n    if (tradeType === TradeType.EXACT_OUTPUT && currencyIn && quoteResult) {\n      otherAmount = CurrencyAmount.fromRawAmount(currencyIn, quoteResult.quote)\n    }\n\n    if (error || !otherAmount || !route || route.length === 0 || !queryArgs) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined,\n      }\n    }\n\n    try {\n      const trade = transformRoutesToTrade(route, tradeType, gasUseEstimateUSD)\n      return {\n        // always return VALID regardless of isFetching status\n        state: TradeState.VALID,\n        trade,\n      }\n    } catch (e) {\n      console.debug('transformRoutesToTrade failed: ', e)\n      return { state: TradeState.INVALID, trade: undefined }\n    }\n  }, [currencyIn, currencyOut, loading, quoteResult, tradeType, error, route, queryArgs, gasUseEstimateUSD])\n}\n"],"sourceRoot":""}