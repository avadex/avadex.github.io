{"version":3,"sources":["lib/hooks/routing/useClientSideSmartOrderRouterTrade.ts","lib/hooks/swap/useBestTrade.ts"],"names":["config","protocols","Protocol","V2","V3","useClientSideSmartOrderRouterTrade","tradeType","amountSpecified","otherCurrency","chainId","currency","library","useActiveWeb3React","useMemo","TradeType","EXACT_INPUT","currencyIn","currencyOut","queryArgs","useRoutingAPIArguments","tokenIn","tokenOut","amount","useClientSideRouter","params","provider","useState","loading","setLoading","quoteResult","undefined","error","setFetchedResult","useEffect","a","getClientSideQuote","result","data","fetchQuote","route","computeRoutes","gasUseEstimateUSD","useStablecoinAmountFromFiatValue","state","TradeState","INVALID","trade","LOADING","otherAmount","CurrencyAmount","fromRawAmount","quote","EXACT_OUTPUT","length","NO_ROUTE_FOUND","transformRoutesToTrade","VALID","e","console","debug","useBestTrade","useDebounce","debouncedAmount","debouncedOtherCurrency","clientSORTrade","inputAmount","outputAmount","getTradeInputs","amountFromLatestTrade","currencyFromTrade","otherCurrencyFromTrade","debouncing","syncing","amounts","indepdenentCurrencies","dependentCurrencies","amountsMatch","equalTo","currenciesMatch","equals","isTradeDebouncing","useFallback","fallbackTrade","useClientSideV3Trade","SYNCING"],"mappings":"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","file":"static/js/67.927ce624.chunk.js","sourcesContent":["import { Protocol } from '@uniswap/router-sdk'\nimport { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { useStablecoinAmountFromFiatValue } from 'hooks/useUSDCPrice'\nimport { useEffect, useMemo, useState } from 'react'\nimport { GetQuoteResult, InterfaceTrade, TradeState } from 'state/routing/types'\nimport { computeRoutes, transformRoutesToTrade } from 'state/routing/utils'\n\nimport useActiveWeb3React from '../useActiveWeb3React'\nimport { getClientSideQuote } from './clientSideSmartOrderRouter'\nimport { useRoutingAPIArguments } from './useRoutingAPIArguments'\n\nconst protocols: Protocol[] = [Protocol.V2, Protocol.V3]\nconst config = { protocols }\n\nexport default function useClientSideSmartOrderRouterTrade<TTradeType extends TradeType>(\n  tradeType: TTradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TTradeType> | undefined\n} {\n  const chainId = amountSpecified?.currency.chainId\n  const { library } = useActiveWeb3React()\n\n  const [currencyIn, currencyOut]: [Currency | undefined, Currency | undefined] = useMemo(\n    () =>\n      tradeType === TradeType.EXACT_INPUT\n        ? [amountSpecified?.currency, otherCurrency]\n        : [otherCurrency, amountSpecified?.currency],\n    [amountSpecified, otherCurrency, tradeType]\n  )\n\n  const queryArgs = useRoutingAPIArguments({\n    tokenIn: currencyIn,\n    tokenOut: currencyOut,\n    amount: amountSpecified,\n    tradeType,\n    useClientSideRouter: true,\n  })\n  const params = useMemo(() => chainId && library && { chainId, provider: library }, [chainId, library])\n\n  const [loading, setLoading] = useState(false)\n  const [{ quoteResult, error }, setFetchedResult] = useState<{\n    quoteResult: GetQuoteResult | undefined\n    error: unknown\n  }>({\n    quoteResult: undefined,\n    error: undefined,\n  })\n\n  // When arguments update, make a new call to SOR for updated quote\n  useEffect(() => {\n    setLoading(true)\n    fetchQuote()\n\n    async function fetchQuote() {\n      try {\n        if (queryArgs && params) {\n          const result = await getClientSideQuote(queryArgs, params, config)\n          setFetchedResult({\n            quoteResult: result.data,\n            error: result.error,\n          })\n        }\n      } catch (e) {\n        setFetchedResult({\n          quoteResult: undefined,\n          error: true,\n        })\n      } finally {\n        setLoading(false)\n      }\n    }\n  }, [queryArgs, params])\n\n  const route = useMemo(\n    () => computeRoutes(currencyIn, currencyOut, tradeType, quoteResult),\n    [currencyIn, currencyOut, quoteResult, tradeType]\n  )\n\n  // get USD gas cost of trade in active chains stablecoin amount\n  const gasUseEstimateUSD = useStablecoinAmountFromFiatValue(quoteResult?.gasUseEstimateUSD) ?? null\n\n  return useMemo(() => {\n    if (!currencyIn || !currencyOut) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined,\n      }\n    }\n\n    if (loading && !quoteResult) {\n      // only on first hook render\n      return {\n        state: TradeState.LOADING,\n        trade: undefined,\n      }\n    }\n\n    let otherAmount = undefined\n    if (tradeType === TradeType.EXACT_INPUT && currencyOut && quoteResult) {\n      otherAmount = CurrencyAmount.fromRawAmount(currencyOut, quoteResult.quote)\n    }\n    if (tradeType === TradeType.EXACT_OUTPUT && currencyIn && quoteResult) {\n      otherAmount = CurrencyAmount.fromRawAmount(currencyIn, quoteResult.quote)\n    }\n\n    if (error || !otherAmount || !route || route.length === 0 || !queryArgs) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined,\n      }\n    }\n\n    try {\n      const trade = transformRoutesToTrade(route, tradeType, gasUseEstimateUSD)\n      return {\n        // always return VALID regardless of isFetching status\n        state: TradeState.VALID,\n        trade,\n      }\n    } catch (e) {\n      console.debug('transformRoutesToTrade failed: ', e)\n      return { state: TradeState.INVALID, trade: undefined }\n    }\n  }, [currencyIn, currencyOut, loading, quoteResult, tradeType, error, route, queryArgs, gasUseEstimateUSD])\n}\n","import { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { useClientSideV3Trade } from 'hooks/useClientSideV3Trade'\nimport useDebounce from 'hooks/useDebounce'\nimport { useMemo } from 'react'\nimport { InterfaceTrade, TradeState } from 'state/routing/types'\n\nimport useClientSideSmartOrderRouterTrade from '../routing/useClientSideSmartOrderRouterTrade'\n\n/**\n * Returns the currency amount from independent field, currency from independent field,\n * and currency from dependent field.\n */\nfunction getTradeInputs(\n  trade: InterfaceTrade<Currency, Currency, TradeType> | undefined,\n  tradeType: TradeType\n): [CurrencyAmount<Currency> | undefined, Currency | undefined, Currency | undefined] {\n  if (trade) {\n    if (tradeType === TradeType.EXACT_INPUT) {\n      return [trade.inputAmount, trade.inputAmount.currency, trade.outputAmount.currency]\n    }\n    if (tradeType === TradeType.EXACT_OUTPUT) {\n      return [trade.outputAmount, trade.outputAmount.currency, trade.inputAmount.currency]\n    }\n  }\n  return [undefined, undefined, undefined]\n}\n\ninterface TradeDebouncingParams {\n  amounts: [CurrencyAmount<Currency> | undefined, CurrencyAmount<Currency> | undefined]\n  indepdenentCurrencies: [Currency | undefined, Currency | undefined]\n  dependentCurrencies: [Currency | undefined, Currency | undefined]\n}\n\n/**\n * Returns wether debounced values are stale compared to latest values from trade.\n */\nfunction isTradeDebouncing({ amounts, indepdenentCurrencies, dependentCurrencies }: TradeDebouncingParams): boolean {\n  // Ensure that amount from user input matches latest trade.\n  const amountsMatch = amounts[0] && amounts[1]?.equalTo(amounts[0])\n\n  // Ensure active swap currencies match latest trade.\n  const currenciesMatch =\n    indepdenentCurrencies[0] &&\n    indepdenentCurrencies[1]?.equals(indepdenentCurrencies[0]) &&\n    dependentCurrencies[0] &&\n    dependentCurrencies[1]?.equals(dependentCurrencies[0])\n\n  return !amountsMatch || !currenciesMatch\n}\n\n/**\n * Returns the best v2+v3 trade for a desired swap.\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\nexport function useBestTrade(\n  tradeType: TradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TradeType> | undefined\n} {\n  // Debounce is used to prevent excessive requests to SOR, as it is data intensive.\n  // This helps provide a \"syncing\" state the UI can reference for loading animations.\n  const [debouncedAmount, debouncedOtherCurrency] = useDebounce(\n    useMemo(() => [amountSpecified, otherCurrency], [amountSpecified, otherCurrency]),\n    200\n  )\n\n  const clientSORTrade = useClientSideSmartOrderRouterTrade(tradeType, debouncedAmount, debouncedOtherCurrency)\n\n  const [amountFromLatestTrade, currencyFromTrade, otherCurrencyFromTrade] = getTradeInputs(\n    clientSORTrade.trade,\n    tradeType\n  )\n\n  const debouncing =\n    (amountSpecified && debouncedAmount && amountSpecified !== debouncedAmount) ||\n    (amountSpecified && debouncedOtherCurrency && otherCurrency && debouncedOtherCurrency !== otherCurrency)\n\n  const syncing =\n    amountSpecified &&\n    isTradeDebouncing({\n      amounts: [amountFromLatestTrade, amountSpecified],\n      indepdenentCurrencies: [currencyFromTrade, amountSpecified?.currency],\n      dependentCurrencies: [otherCurrencyFromTrade, debouncedOtherCurrency],\n    })\n\n  const useFallback = !syncing && clientSORTrade.state === TradeState.NO_ROUTE_FOUND\n\n  // Use a simple client side logic as backup if SOR is not available.\n  const fallbackTrade = useClientSideV3Trade(\n    tradeType,\n    useFallback ? debouncedAmount : undefined,\n    useFallback ? debouncedOtherCurrency : undefined\n  )\n\n  return useMemo(\n    () => ({\n      ...(useFallback ? fallbackTrade : clientSORTrade),\n      ...(syncing ? { state: TradeState.SYNCING } : {}),\n      ...(debouncing ? { state: TradeState.LOADING } : {}),\n    }),\n    [debouncing, fallbackTrade, syncing, clientSORTrade, useFallback]\n  )\n}\n"],"sourceRoot":""}